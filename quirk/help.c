//
// Copyright (c) 2015 zh
// All rights reserved.
//

#include <stdio.h>
#include <stdlib.h>

#include "help.h"

static const char *USAGE =
"# ZHSH 用户手册\n"
"\n"
"ZHSH 是张海写作的一个简单的 Shell 实现。\n"
"\n"
"本程序无任何担保，详情见 GNU 通用公共许可证，第二版或以上。"
"\n"
"## 提示\n"
"\n"
"本 Shell 的提示字符格式为`用户名@主机名 当前工作目录 $ `或`主机名 当前工作目录 # `（有效用户为 root），并且使用 ANSI 标准转义代码在终端显示颜色和标题。\n"
"\n"
"在提示后可以输入命令，按下回车命令执行完成后会重新打印提示并继续接受命令输入。\n"
"\n"
"## 命令\n"
"\n"
"Shell 命令由以下部分组成：\n"
"\n"
"- 命令名称\n"
"- 零或多个命令参数\n"
"- 零或多个输入/输出重定向（见下文）\n"
"\n"
"多条命令间可以由以下符号连接：\n"
"\n"
"- |：管道（见下文）\n"
"- &：后台执行前一个命令，可以出现在复合命令的最后。\n"
"- ||：仅当前一条命令不正确退出时执行下一条命令。\n"
"- &&：仅当前一条命令正确退出时执行下一条命令。\n"
"- ;：按顺序执行命令。\n"
"\n"
"符号可以将命令名称、参数等拆分，此时命令中的相关空格是可选的。\n"
"\n"
"## 管道\n"
"\n"
"管道（|）可以将上一条命令的输出作为下一条命令的输入。\n"
"\n"
"例如，`ls|sort`可以将`ls`的结果经过排序后输出。\n"
"\n"
"管道对于标准输入和标准输出的重定向会被命令中的输入/输出重定向覆盖。\n"
"\n"
"## 输入/输出重定向\n"
"\n"
"输入/输出重定向是将命令对某个文件描述符的输入/输出操作重定向至另一个文件描述符或文件的功能。\n"
"\n"
"Shell 总是有三个默认的文件描述符：标准输入（0）、标准输出（1）和标准错误输出（2）。用户可以对它们进行重定向。\n"
"\n"
"支持的重定向的格式：\n"
"\n"
"- 命令 [文件描述符] < 文件：将命令执行时从文件描述符读取的内容重定向自文件。文件描述符默认为0，即标准输入。\n"
"\n"
"例如，`cat </etc/passwd`将会打印`/etc/passwd`的内容。\n"
"\n"
"- 命令 [文件描述符1] <& 文件描述符2：将命令执行时从文件描述符1读取的内容重定向自文件描述符2。文件描述符1默认为0，即标准输入。\n"
"\n"
"- 命令 [文件描述符] > 文件：将命令执行时写入至文件描述符的内容重定向至文件，文件的原内容将被覆盖。文件描述符默认为1，即标准输出。\n"
"\n"
"例如，`ls >ls.out`会将`ls`的标准输出内容写入至`ls.out`并替换原有内容。\n"
"\n"
"- 命令 [文件描述符1] >& 文件描述符2：将命令执行时写入至文件描述符1的内容重定向至文件描述符2。文件描述符1默认为1，即标准输出。\n"
"\n"
"例如，`ls >/dev/null 2>&1`会将`ls`的标准输出和标准错误输出一起丢弃。\n"
"\n"
"- 命令 [文件描述符] >> 文件：将命令执行时写入至文件描述符的内容重定向至文件，文件的原内容将被保留，新的内容将被附加在其后。文件描述符默认为1，即标准输出。\n"
"\n"
"例如，`ls >>ls.out`会将`ls`的标准输出内容写入至`ls.out`原有内容之后。\n"
"\n"
"## 后台执行\n"
"\n"
"默认情况下，Shell 将等待当前命令结束之后，再提示用户输入新的命令。通过在命令末尾加上`&`，可以使得 Shell 不等待此命令执行结束，即提示用户输入新的命令。\n"
"\n"
"## 环境\n"
"\n"
"每个程序执行时，都有一个自己的环境，其中可以包含零到多个环境变量；在`fork`新进程后，新进程会继承父进程的环境。\n"
"\n"
"部分常见的环境变量：\n"
"\n"
"- PATH：Shell 查找用户命令对应可执行文件所搜索的目录。\n"
"- HOME：用户的家目录路径。\n"
"- SHELL：当前 Shell 可执行文件的绝对路径。\n"
"- TERM：当前终端的类型。\n"
"- PWD：当前工作目录的路径。\n"
"- OLDPWD：上一工作目录的路径。\n"
"\n"
"本 Shell 会自动设置`SHELL`、`PWD`和`OLDPWD`三个环境变量，并且在子进程中会设置`PARENT`环境变量，其值等于`SHELL`。\n"
"\n"
"本 Shell 支持使用内建命令`export`和`unset`来修改环境变量。\n"
"\n"
"## 内建命令\n"
"\n"
"本 Shell 实现了以下内建命令：\n"
"\n"
"- cd：改变当前工作目录到指定目录或家目录。\n"
"- exit：退出 Shell。\n"
"- export：设置环境变量。\n"
"- logout：作为登录 Shell 时退出 Shell。\n"
"- unset：移除环境变量。\n"
"- clr：清除屏幕。\n"
"- dir：列出指定目录或当前工作目录。\n"
"- echo：打印所有命令参数和换行，参数在打印时以空格间隔。\n"
"- environ：列出所有环境变量。\n"
"- help：打印帮助。\n"
"- quit：退出 Shell。\n"
"\n"
"## 构建\n"
"\n"
"本 Shell 使用 Readline 进行输入，因此构建时需要 Readline 头文件作为依赖已经安装。\n"
"\n"
"本 Shell 使用 flex 和 lemon 进行语法分析，因此构建时需要两者作为依赖已经安装。\n"
"\n"
"本 Shell 在开发时使用 CMake 进行构建，因此构建时可以将其作为依赖安装。\n"
"\n"
"安装 flex、lemon 和 CMake 后，使用`cmake . && make`命令进行编译即可。\n"
"\n"
"如果没有安装 CMake，也可以使用本 Shell 附带的 Makefile。使用`make`命令进行编译即可。\n"
"\n"
"## 实现\n"
"\n"
"本 Shell 使用 Readline 获取用户命令输入，并且支持行编辑、Emacs/Vim 风格快捷键和命令行历史。\n"
"\n"
"本 Shell 使用 flex 作为词法分析器，lemon 作为语法解析器，对命令进行解析。\n"
"\n"
"本 Shell 实现了良好的系统调用错误处理、文件描述符管理和内存管理。在通过`valgrind`内存泄漏检测工具的检测中未发现内存泄漏。\n";

int help() {
    FILE *pipe = popen("more", "w");
    fprintf(pipe, USAGE);
    pclose(pipe);
    return EXIT_SUCCESS;
}
